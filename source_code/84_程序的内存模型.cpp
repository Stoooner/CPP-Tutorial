#include <iostream>
using namespace std;

/* 
    1. C++程序在执行的时候，将内存大方向划分为了4个区域：
        - 代码区：存放函数体的二进制代码，有操作系统进行管理；
        - 全局区：存放全局变量和静态变量以及常量；
        - 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等；
        - 堆区：由程序员分配和释放，若程序员不释放，程序结束后由操作系统回收；
    2. 内存四区存在的意义：
        不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程；
    3. 程序运行之前：
        在程序编译后，生成了exe可执行文件，未执行该程序之前分为两个区域：
            代码区：
                - 存放CPU执行的机器指令；
                - 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可；
                - 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令；
            全局区：
                - 全局变量和静态变量存放在此；
                - 全局区还包含常量区，字符串常量和其他常量(const修饰的一些全局变量)也存放在此；
                - 该区域的数据在程序结束后由操作系统释放；
    4. 程序运行之后：
        栈区：
            - 由编译器自动分配释放，存放函数的参数值，局部变量等；
            - 注意事项：不要返回局部变量的值，因为栈区开辟的数据由编译器自动释放；
        堆区：
            - 由程序员分配释放，若程序员不释放，程序结束后会由操作系统回收；
            - 在C++中主要利用new在堆区开辟内存；
    5. new操作符：
        - C++利用new操作符在堆区开辟数据；
        - 堆区开辟的数据有由程序员手动开辟，手动释放，释放时利用操作符delete；
        - 利用new创建的数据，会返回该数据对应的类型的指针；
*/

// 全局变量：
int g_a = 10;
int g_b = 10;
// const修饰的全局变量-->全局常量
const int c_g_a = 10;
const int c_g_b = 10;

// 错误演示，记住不要返回局部变量的地址
int * func(int b){ // 形参数据也会放在栈区
    b = 100;
    int a = 10;// 局部变量，存放在了栈区，栈区的数据在函数执行完后自动释放
    return &a;
}

int * func2(){
    // 利用new关键字可以将数据开辟到堆区
    // new int(10)在堆区开辟空间存放数据，并会返回这个空间的地址，因此使用指针int *p去接收
    // 这个指针本质也是局部变量，放在栈上，指针保存的数据是放在了堆区
    int * p = new int(10);
    return p;
}

void test01(){
    int *p = func2();
    cout << "xxx: " << *p << endl; 
    cout << "xxx: " << *p << endl; 
    cout << "xxx: " << *p << endl; 
    // delete用于释放堆区的数据
    delete p;
    cout << "xxx: " << *p << endl; // 内存已被delete释放，再次访问就是非法操作，会报错
}

// 在堆区利用new开辟数组
void test02(){
    // 这里中括号[10]代表的是创建一个包含10个"int型元素"的数组，里面每个元素默认值为0；
    int * arr = new int[10];
    for (int i=0;i<10;i++){
        arr[i] = i + 100;
    }
    for (int i=0;i<10;i++){
        cout << arr[i] << endl;
    }
    // 释放堆区数组，需要加[]才可以；
    delete[] arr; 
}

int main(){
    // 全局区： 全局变量、静态变量、常量(全局常量、字符串常量)

    // 创建一个普通的局部变量(写在函数体内的变量)：
    int a = 10;
    int b = 10;
    cout << "局部变量a的地址: " << (long long)&a << endl; 
    cout << "局部变量b的地址: " << (long long)&b << endl; 
    cout << "全局变量g_a的地址: " << (long long)&g_a << endl; 
    cout << "全局变量g_b的地址: " << (long long)&g_b << endl; 

    // 静态变量
    static int s_a = 10;
    static int s_b = 10;
    cout << "静态变量s_a的地址: " << (long long)&s_a << endl; 
    cout << "静态变量s_b的地址: " << (long long)&s_b << endl; 

    // 常量：字符串常量，const修饰的变量
    cout << "字符串常量的地址： " << (long long)&"hello world" << endl;
    cout << "全局常量的地址： " << (long long)&c_g_a << endl;
    cout << "全局常量的地址： " << (long long)&c_g_b << endl;
    // const修饰的局部变量--->局部常量，它虽然是常量，但是由于是局部的，因此它不在全局区，它和局部变量一样，都不在全局区
    const int c_l_a = 10;
    const int c_l_b = 10;
    cout << "局部常量的地址： " << (long long)&c_l_a << endl;
    cout << "局部常量的地址： " << (long long)&c_l_b << endl;

    // 接收func返回的值(错误示例)
    int *p = func(1);
    // cout << "返回局部变量的地址示例1： " << *p << endl; // 第一次的时候，虽然按func()运行结束了，但是编译器还会帮你保留一次func返回的值
    // cout << "返回局部变量的地址示例2： " << *p << endl; // 第二次这个数据就不再保留了

    // 堆区
    int *p2 = func2();
    // 只要我不去释放在堆区开辟的空间的数据，这个数据就会一直保留，除非程序运行完毕，然后被系统给回收
    cout << "返回堆区数据的地址示例1： " << *p2 << endl;
    cout << "返回堆区数据的地址示例2： " << *p2 << endl; 

    test01();
    test02();

    system("pause");
    return 0;
}